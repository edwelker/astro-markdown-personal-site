---
import Layout from "@layouts/Layout.astro";
import gasData from "@data/gas.json";

export function getStaticPaths() {
  return [
    { params: { region: "md" }, props: { name: "Maryland", data: gasData.md } },
    { params: { region: "ny" }, props: { name: "New York", data: gasData.ny } },
    { params: { region: "ma" }, props: { name: "Massachusetts", data: gasData.ma } },
  ];
}

const { region } = Astro.params;
const { name, data: rawData } = Astro.props;

const title = `Gas Prices - ${name}`;
const description = `Latest gas prices for ${name}.`;

function formatPrice(price: string | number) {
  if (price === undefined || price === null || price === '') return '';
  const num = parseFloat(String(price).replace(/[^0-9.-]+/g, ""));
  return isNaN(num) ? String(price) : num.toFixed(2);
}

// Normalize keys and Ensure Net price exists and Sort
const data = rawData.map((row: any) => {
  // Helper to get value case-insensitively
  const getVal = (key: string) => {
    if (row[key] !== undefined) return row[key];
    const lowerKey = key.toLowerCase();
    const foundKey = Object.keys(row).find(k => k.toLowerCase() === lowerKey);
    return foundKey ? row[foundKey] : undefined;
  };

  let net = getVal('Net');
  const baseRaw = getVal('Base');
  const discountRaw = getVal('Discount');

  // Check if net is missing or empty string
  if (net === undefined || net === null || String(net).trim() === '') {
    const baseStr = String(baseRaw || "").replace(/[^0-9.-]+/g, "");
    const discountStr = String(discountRaw || "0").replace(/[^0-9.-]+/g, "");
    
    const base = parseFloat(baseStr);
    const discount = parseFloat(discountStr);
    
    if (!isNaN(base)) {
      // Default discount to 0 if NaN
      const finalDiscount = isNaN(discount) ? 0 : discount;
      net = (base - finalDiscount).toFixed(2);
    } else {
      // If base is invalid, keep net as is (likely empty or undefined)
      net = baseRaw; 
    }
  }

  let city = getVal('City');
  // Clean up MD city names (remove parens)
  if (region === 'md' && city) {
    city = city.replace(/\s*\(.*?\)/g, '').trim();
  }
  
  return {
    Station: getVal('Station'),
    Address: getVal('Address'),
    City: city,
    Zip: getVal('Zip'),
    Base: baseRaw,
    Discount: discountRaw,
    Net: net,
    lat: getVal('lat') ?? getVal('latitude'), 
    lng: getVal('lng') ?? getVal('long') ?? getVal('longitude')
  };
}).sort((a: any, b: any) => {
  const netA = parseFloat(String(a.Net).replace(/[^0-9.-]+/g, ""));
  const netB = parseFloat(String(b.Net).replace(/[^0-9.-]+/g, ""));
  
  // Handle NaNs by pushing them to the end
  if (isNaN(netA) && isNaN(netB)) return 0;
  if (isNaN(netA)) return 1;
  if (isNaN(netB)) return -1;
  
  return netA - netB;
});
---

<Layout title={title} description={description}>
  <div class="w-full px-2 sm:px-4 py-8">
    <div class="animate" data-pagefind-body>
      <div class="mb-6 max-w-screen-md mx-auto">
        <a href="/gas" class="text-sm text-neutral-500 hover:text-black dark:hover:text-white transition-colors">← Back to Gas</a>
        <h1 class="font-semibold text-2xl mt-2">{name} Gas Prices</h1>
      </div>

      <div class="mb-4 max-w-screen-md mx-auto flex flex-col sm:flex-row gap-3">
        <input
          type="text"
          id="gas-filter"
          placeholder="Filter by City or Zip..."
          class="flex-grow px-4 py-2 border border-neutral-200 dark:border-neutral-700 rounded-lg bg-transparent focus:outline-none focus:ring-2 focus:ring-neutral-500"
        />
        <button
          id="sort-distance"
          class="px-4 py-2 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700 rounded-lg text-sm font-medium transition-colors whitespace-nowrap"
        >
          Calculate Driving Times
        </button>
      </div>

      <div id="distance-status" style="display: none;" class="mb-4 max-w-screen-md mx-auto text-xs text-neutral-500 italic text-center">
        Calculating driving times...
      </div>
      
      <div class="overflow-x-auto">
        <table class="w-full text-xs sm:text-sm text-left whitespace-nowrap">
          <thead class="text-neutral-500 uppercase bg-neutral-50 dark:bg-neutral-800 dark:text-neutral-400">
            <tr>
              <th class="px-2 py-3 select-none">Station</th>
              <th class="px-2 py-3 select-none">Address</th>
              <th class="px-2 py-3 cursor-pointer hover:text-black dark:hover:text-white select-none" data-sort="City" data-label="City">City ↕</th>
              <th class="hidden sm:table-cell px-2 py-3 cursor-pointer hover:text-black dark:hover:text-white select-none" data-sort="Zip" data-label="Zip">Zip ↕</th>
              <th class="px-2 py-3 text-right cursor-pointer hover:text-black dark:hover:text-white select-none" data-sort="Base" data-label="Price">Price ↕</th>
              <th class="hidden sm:table-cell px-2 py-3 text-right select-none">Discount</th>
              <th class="px-2 py-3 text-right cursor-pointer hover:text-black dark:hover:text-white select-none" data-sort="Net" data-label="Net">Net ↑</th>
              <th class="px-2 py-3 text-right cursor-pointer hover:text-black dark:hover:text-white select-none" data-sort="Time" data-label="Time">Time ↕</th>
            </tr>
          </thead>
          <tbody id="gas-table-body">
            {data.map((row) => (
              <tr 
                class="border-b border-neutral-200 dark:border-neutral-700 hover:bg-neutral-50 dark:hover:bg-neutral-800/50"
                data-lat={row.lat}
                data-lng={row.lng}
              >
                <td class="px-2 py-3 font-medium">{row.Station}</td>
                <td class="px-2 py-3">
                  <a 
                    href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(`${row.Address}, ${row.City} ${row.Zip}`)}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    class="hover:underline"
                  >
                    {row.Address}
                  </a>
                </td>
                <td class="px-2 py-3">{row.City}</td>
                <td class="hidden sm:table-cell px-2 py-3">{row.Zip}</td>
                <td class="px-2 py-3 text-right">{formatPrice(row.Base)}</td>
                <td class="hidden sm:table-cell px-2 py-3 text-right">{row.Discount}</td>
                <td class="px-2 py-3 text-right font-bold">{formatPrice(row.Net)}</td>
                <td class="px-2 py-3 text-right text-neutral-400 italic">—</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      <p class="text-xs text-neutral-400 mt-4 text-center">
        Data sourced from <a href="https://github.com/edwelker/find_cheap_local_gas" class="underline">edwelker/find_cheap_local_gas</a>.
      </p>
    </div>
  </div>
</Layout>

<script define:vars={{ initialData: data }}>
  console.log("Gas script initialized. Total rows:", initialData.length);

  let sortCol = 'Net';
  let sortAsc = true;
  let filterQuery = "";
  let userCoords = null;
  let distances = {}; // Keyed by Address: { duration: seconds, distance: miles }

  const tableBody = document.getElementById('gas-table-body');
  const filterInput = document.getElementById('gas-filter');
  const distanceBtn = document.getElementById('sort-distance');
  const distanceStatus = document.getElementById('distance-status');
  const headers = document.querySelectorAll('th[data-sort]');

  function formatPrice(val) {
    if (val === undefined || val === null || val === '') return '';
    const num = parseFloat(String(val).replace(/[^0-9.-]+/g, ""));
    return isNaN(num) ? String(val) : num.toFixed(2);
  }

  function parseCurrency(val) {
    if (typeof val !== 'string') return val;
    const num = parseFloat(val.replace(/[^0-9.-]+/g,""));
    return isNaN(num) ? undefined : num;
  }

  async function calculateAllDistances() {
    console.log("calculateAllDistances triggered");
    
    // Show status immediately
    distanceStatus.style.display = 'block';
    distanceStatus.textContent = "Waiting for location permission...";
    distanceBtn.disabled = true;
    distanceBtn.textContent = "Calculating...";

    if (!userCoords) {
      try {
        console.log("Requesting geolocation...");
        const pos = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 10000 });
        });
        userCoords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
        console.log("User coords acquired:", userCoords);
      } catch (e) {
        console.error("Geolocation error:", e);
        alert("Unable to get your location. Please ensure location services are enabled and try again.");
        distanceStatus.style.display = 'none';
        distanceBtn.disabled = false;
        distanceBtn.textContent = "Calculate Driving Times";
        return;
      }
    }

    // If we already have distances for all rows in memory, just update table
    const allKnown = initialData.every(row => {
        const lat = parseFloat(row.lat);
        const lng = parseFloat(row.lng);
        const hasCoords = !isNaN(lat) && !isNaN(lng);
        return !hasCoords || distances[row.Address] !== undefined;
    });

    if (allKnown && initialData.some(row => distances[row.Address] !== undefined)) {
      console.log("All distances already known. Updating table.");
      updateTable();
      distanceStatus.style.display = 'none';
      distanceBtn.disabled = false;
      distanceBtn.textContent = "Calculate Driving Times";
      return;
    }

    console.log("Filtering rows to fetch...");
    const seen = new Set();
    const toFetch = initialData.filter(row => {
      const lat = parseFloat(row.lat);
      const lng = parseFloat(row.lng);
      const hasCoords = !isNaN(lat) && !isNaN(lng);
      const notKnown = distances[row.Address] === undefined;
      const isNew = !seen.has(row.Address);
      if (hasCoords && notKnown && isNew) {
        seen.add(row.Address);
        return true;
      }
      return false;
    });

    console.log(`Unique rows with valid coordinates to fetch: ${toFetch.length}`);

    if (toFetch.length === 0) {
      console.warn("No rows found with valid lat/lng coordinates.");
      alert("No location data found for these stations. Driving times cannot be calculated.");
      distanceStatus.style.display = 'none';
      distanceBtn.disabled = false;
      distanceBtn.textContent = "Calculate Driving Times";
      return;
    }

    let completed = 0;
    const total = toFetch.length;
    
    const updateProgress = () => {
      distanceStatus.textContent = `Calculating driving times... ${completed}/${total}`;
    };

    updateProgress();

    // ORS Matrix API limit is 50 locations per request (1 source + 49 destinations)
    const batchSize = 49;
    for (let i = 0; i < toFetch.length; i += batchSize) {
      const batch = toFetch.slice(i, i + batchSize);
      console.log(`Fetching batch ${Math.floor(i / batchSize) + 1} of ${Math.ceil(total / batchSize)}. Size: ${batch.length}`);
      
      try {
        const res = await fetch('/api/matrix', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            locations: [[userCoords.lon, userCoords.lat], ...batch.map(r => [parseFloat(r.lng), parseFloat(r.lat)])],
            sources: [0],
            destinations: Array.from({length: batch.length}, (_, idx) => idx + 1),
            metrics: ["duration", "distance"],
            units: "mi"
          })
        });

        console.log(`API response status for batch ${Math.floor(i / batchSize) + 1}:`, res.status);

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.message || `HTTP ${res.status}`);
        }

        const result = await res.json();
        console.log("API result received for batch.");
        
        batch.forEach((row, idx) => {
          if (result.durations && result.durations[0][idx] !== null) {
            distances[row.Address] = {
              duration: result.durations[0][idx],
              distance: result.distances[0][idx]
            };
          } else {
            console.warn(`ORS returned null duration for station: ${row.Station} at ${row.Address} (Coords: ${row.lat}, ${row.lng})`);
          }
        });
        
        completed += batch.length;
        updateProgress();
        updateTable();
      } catch (e) {
        console.error("Matrix calculation failed:", e);
        alert(`Failed to calculate driving times: ${e.message}. Check console for details.`);
        distanceStatus.style.display = 'none';
        distanceBtn.disabled = false;
        distanceBtn.textContent = "Calculate Driving Times";
        break;
      }

      // Small delay between batches if multiple
      if (i + batchSize < toFetch.length) {
        await new Promise(r => setTimeout(r, 500));
      }
    }

    console.log("Calculation finished.");
    distanceStatus.style.display = 'none';
    distanceBtn.disabled = false;
    distanceBtn.textContent = "Calculate Driving Times";
    updateTable();
  }

  function renderTable(data) {
    tableBody.innerHTML = data.map(row => {
      const d = distances[row.Address];
      const displayStr = d ? `${Math.round(d.duration / 60)}m (${d.distance.toFixed(1)}mi)` : '—';
      return `
      <tr 
        class="border-b border-neutral-200 dark:border-neutral-700 hover:bg-neutral-50 dark:hover:bg-neutral-800/50"
        data-lat="${row.lat || ''}"
        data-lng="${row.lng || ''}"
      >
        <td class="px-2 py-3 font-medium">${row.Station || ''}</td>
        <td class="px-2 py-3">
          <a 
            href="https://www.google.com/maps/search/?api=1&query=${encodeURIComponent((row.Address || '') + ', ' + (row.City || '') + ' ' + (row.Zip || ''))}"
            target="_blank"
            rel="noopener noreferrer"
            class="hover:underline"
          >
            ${row.Address || ''}
          </a>
        </td>
        <td class="px-2 py-3">${row.City || ''}</td>
        <td class="hidden sm:table-cell px-2 py-3">${row.Zip || ''}</td>
        <td class="px-2 py-3 text-right">${formatPrice(row.Base)}</td>
        <td class="hidden sm:table-cell px-2 py-3 text-right">${row.Discount || ''}</td>
        <td class="px-2 py-3 text-right font-bold">${formatPrice(row.Net)}</td>
        <td class="px-2 py-3 text-right ${d ? '' : 'text-neutral-400 italic'}">${displayStr}</td>
      </tr>
    `}).join('');
  }

  function updateTable() {
    // Filter
    let filtered = initialData.filter(row => {
      const cityMatch = row.City && row.City.toLowerCase().includes(filterQuery);
      const zipMatch = row.Zip && row.Zip.toString().includes(filterQuery);
      return cityMatch || zipMatch;
    });

    // Sort
    if (sortCol) {
      filtered.sort((a, b) => {
        let valA, valB;

        if (sortCol === 'Time') {
          valA = distances[a.Address]?.duration ?? Infinity;
          valB = distances[b.Address]?.duration ?? Infinity;
          if (valA === null) valA = Infinity;
          if (valB === null) valB = Infinity;
        } else if (['Base', 'Net', 'Discount'].includes(sortCol)) {
          valA = parseCurrency(a[sortCol]);
          valB = parseCurrency(b[sortCol]);
          
          if (valA === undefined && valB === undefined) return 0;
          if (valA === undefined) return 1;
          if (valB === undefined) return -1;
        } else {
          valA = (a[sortCol] || "").toString().toLowerCase();
          valB = (b[sortCol] || "").toString().toLowerCase();
        }

        if (valA < valB) return sortAsc ? -1 : 1;
        if (valA > valB) return sortAsc ? 1 : -1;
        
        // Tie-breaker: cheaper Net price first
        const netA = parseCurrency(a.Net) ?? Infinity;
        const netB = parseCurrency(b.Net) ?? Infinity;
        return netA - netB;
      });
    }
    
    // Update Headers
    headers.forEach(th => {
      const col = th.getAttribute('data-sort');
      const label = th.getAttribute('data-label');
      let arrow = ' ↕';
      if (col === sortCol) {
        arrow = sortAsc ? ' ↑' : ' ↓';
      }
      th.textContent = label + arrow;
    });

    renderTable(filtered);
  }

  headers.forEach(th => {
    th.addEventListener('click', () => {
      const column = th.getAttribute('data-sort');
      console.log("Header clicked:", column);
      if (column === 'Time' && !userCoords) {
        calculateAllDistances();
        return;
      }
      if (sortCol === column) {
        sortAsc = !sortAsc;
      } else {
        sortCol = column;
        sortAsc = true;
      }
      updateTable();
    });
  });

  filterInput.addEventListener('input', (e) => {
    filterQuery = e.target.value.toLowerCase();
    updateTable();
  });

  distanceBtn.addEventListener('click', () => {
    console.log("Button clicked");
    calculateAllDistances();
  });
</script>
